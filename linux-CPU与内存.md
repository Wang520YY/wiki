<!-- GFM-TOC -->
* [cpu基础知识](#cpu基础知识)
<!-- GFM-TOC -->

# cpu基础知识

**物理CPU**   计算机实际配置的cpu个数，查看命令 cat /proc/cpuinfo | grep "physical id" | sort -u | wc -l

**cpu核数**   cpu上集中处理数据的cpu核心个数，如果核心数1个，个数4个，就是4核， 查看命令 cat /proc/cpuinfo | grep "cpu cores" | uniq | wc -l

**逻辑cpu**   如果物理cpu支持超线程，逻辑cpu就是核心数的两倍，查看命令 cat /proc/cpuinfo | grep "processor" | wc -l

**超线程**   一项技术，使得单个处理器可以像两个逻辑处理器那样运行，这样单个处理器以并行执行线程

**单核**

![image](https://github.com/Wang520YY/wiki/blob/master/images/单核.jpg)
 
 **多核**
 
![image](https://github.com/Wang520YY/wiki/blob/master/images/多核.jpg)

**超线程**

 ![image](https://github.com/Wang520YY/wiki/blob/master/images/超线程.jpg)

**时钟频率(主频)**     用来表示cpu的运算，处理数据的速度

**指令流水线**    为提高处理器执行指令效率，把一条指令操作分为多个细小的步骤，每个步骤由专门的电路完成

**cpu缓存**    cpu与内存之间临时数据交换器，总共三级缓存（L1一级缓存、L2二级缓存、L3三级缓存）

**cpu运行队列**     

![image](https://github.com/Wang520YY/wiki/blob/master/images/运行队列.png)

一个cpu对应一个运行队列，任务1、2、3均为可执行任务，处于等待阶段
进程是资源分配的最小单元，线程是系统调度的最下单元
D状态：不间断进程(通常为IO)
不可中断状态：比如等待硬件设备的 I/O 响应，当一个进程向磁盘读写数据时，为了保证数据的一致性，在得到磁盘回复前，它是不能被其他进程或者中断打断的

**平均负载(load)**  单位时间内处于可运行(运行中、等待中)状态进程数+处于D状态进程数，也就是系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数

**cpu使用率**      给定时间间隔内通过CPU的不同进程，计算只运行的进程，而不是那些正在等待    

cpu密集型进程，大量使用cpu会使cpu利用率和负载增高
IO密集型，会使平均负载增高，但cpu使用率并不一定增高
大量等待cpu的进程调度会使平均负载增高，cpu使用率也会增高

相关命令    top pidstat cat /proc/stat

user（通常缩写为 us），代表用户态 CPU 时间。注意，它不包括下面的 nice 时间，但包括了 guest 时间。
nice（通常缩写为 ni），代表低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 1-19 之间时的 CPU 时间。
system（通常缩写为 sy），代表内核态 CPU 时间。
idle（通常缩写为 id），代表空闲时间。注意，它不包括等待 I/O 的时间（iowait）。
iowait（通常缩写为 wa），代表等待 I/O 的 CPU 时间。
irq（通常缩写为 hi），代表处理硬中断的 CPU 时间。
softirq（通常缩写为 si），代表处理软中断的 CPU 时间。
steal（通常缩写为 st），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间。
guest（通常缩写为 guest），代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的 CPU 时间。
guest_nice（通常缩写为 gnice），代表以低优先级运行虚拟机的时间。 CPU 使用率 = 1 - 空闲时间 / 总 CPU 时间
CPU 使用率 = 1 - 空闲时间 / 总 CPU 时间

**上下文切换**       从一个进程或线程切换到另一个进程或线程，上下文指某一时间点cpu寄存器和程序计数器的内容
可以理解为，内核挂起cpu当前运行的进程，然后继续执行之前挂起的众多进程中的一个
（1）挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处
（2）在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复
（3）跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程

上半部分：接收中断时立即执行，简单快速，执行时禁止一些或全部中断
下半部分：稍后执行，而且执行期间可以响应所有中断(软中断，tasklet和工作队列)
软中断只能被硬中断打断，可并发运行在多个cpu上，所以必须设计可重入函数，因此需要自旋锁来保护其数据结构
寄存器通过对常用值（通常是运算的中间值）的快速访问来提高计算机程序运行的速度
查看软中断的运行情况  cat /proc/softirqs

R   运行状态
S   自愿睡眠状态
D   非自愿睡眠状态，不可中断睡眠
T   停止状态
X   死亡状态
Z   僵尸状态
t   追踪停止状态

**常用命令**
![image](https://github.com/Wang520YY/wiki/blob/master/images/常用命令.png)

