需求背景
     在很多业务比如电商、支付等场景中，一般都会有遇到生成唯一ID的需求。无论是用于订单号，还是支付交易ID，用作唯一交易凭据，甚至是底层数据异构的依据，分布式的ID生成器服务都是不可或缺。

服务要求
对于ID生成器服务，通常有以下要求：

1、全局唯一性

这是ID生成的天然需求



2、趋势/单调递增

为了保障在持久化存储（如DB）时的写入性能



3、信息安全
防止关键业务信息（如每日订单量）被竞对根据ID数量估算出来



4、系统性能以及高可用

性能满足业务需求，系统稳定高可用



传统生成方式的弊端
1. 内置随机ID函数
使用语言内置的随机ID生成函数，一般会存在 生成的ID位数过长、ID无序、数字字母类型多样 导致入库性能较差等问题。
另外，如果是UUID的生成方式，则需基于机器MAC地址，有一定安全风险，也不是分布式的。

2. 数据库自增主键
对数据库的依赖严重，性能一般不高，可用性也有风险。

3. Redis的INCR方案
最大的问题还在于性能容量，极限一般在20W/s左右，在很多电商场景（如双十一）下无法满足业务需求。



SnowFlake算法
SnowFlake是Twitter公司所采用的一种ID生成算法，最初目的就是在分布式系统中生成全局唯一且趋势递增的ID。目前国内互联网公司的ID生成器，都或多或少的借鉴了这种方式。

  ![image](https://github.com/Wang520YY/wiki/blob/master/images/snowFlake.jpg)

1、第1位代表符号位，始终为0；



2、第2组代表时间戳，精确到毫秒；



3、第3组代表工作机器id，高5位是datacenterId，低5位是workerId；



4、第4组代表序列号，这个值在同一毫秒同一节点上从0开始不断累加；

理论上SnowFlake方案可达到的QPS约为409.6w/s。


SnowFlake方案的优缺点
优点
1、内存生成，不依赖外部DB，系统保障高性能高可用

2、生成的ID呈趋势递增，在插入索引树时表现性能较好

缺点
1、依赖于系统时钟的一致性。如果某台机器的系统时钟回拨，有可能造成ID冲突，或者ID乱序。

2、为了解决时钟问题，有些公司采用ZK去比较当前workerId也就是节点ID使用的时间是否有回拨。如果有回拨就进行休眠固定时间，看是否能赶上时间。如果能赶上的话，就继续生成ID。如果一直没有赶上达到某个值的话，就报错处理。



进一步优化
很多团队对于ID生成器做了进一步的细节优化，比如区分不同业务（BizID）、用户ID尾数+订单ID含义组合、提前生成ID池每次都从中直接获取等。

如果感兴趣，也可以网络上看下滴滴Ice服务、美团点评的Leaf服务等资料，其中使用了多项细节策略，进一步提高了系统性能和稳定性。
